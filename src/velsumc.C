#include "EW.h"
#include "caliper.h"
#include "sw4.h"
void EW::velsum_ci(sw4_type is, sw4_type ie, sw4_type js, sw4_type je, sw4_type ks, sw4_type ke, sw4_type i1,
                   sw4_type i2, sw4_type j1, sw4_type j2, sw4_type k1, sw4_type k2,
                   float_sw4* __restrict__ mu, float_sw4* __restrict__ lambda,
                   float_sw4* __restrict__ rho, float_sw4& cp, float_sw4& cs,
                   size_t& npts) {
  SW4_MARK_FUNCTION;
  const size_t ni = ie - is + 1;
  const size_t nij = ni * (je - js + 1);
  // const size_t nijk  = nij*(ke-ks+1);
  const size_t base = -(is + ni * js + nij * ks);
  cp = cs = 0;
  npts = static_cast<size_t>(i2 - i1 + 1) * static_cast<size_t>(j2 - j1 + 1) *
         (k2 - k1 + 1);
#pragma omp parallel
#pragma omp for reduction(+ : cp, cs)
  for (sw4_type k = k1; k <= k2; k++)
    for (sw4_type j = j1; j <= j2; j++)
      for (sw4_type i = i1; i <= i2; i++) {
        size_t ind = base + i + ni * j + nij * k;
        cp += sqrt((2 * mu[ind] + lambda[ind]) / rho[ind]);
        cs += sqrt(mu[ind] / rho[ind]);
      }
}
