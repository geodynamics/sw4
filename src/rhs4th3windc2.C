#include <cstddef>
#include <cstdio>

#include "Mspace.h"
#include "caliper.h"
#include "cf_interface.h"
#include "foralls.h"
#include "policies.h"
#include "sw4.h"

//-----------------------------------------------------------------------
void update_unext(sw4_type ib, sw4_type ie, sw4_type jb, sw4_type je, sw4_type kb, sw4_type ke,
                  float_sw4* __restrict__ a_unext, float_sw4* __restrict__ a_up,
                  float_sw4* __restrict__ a_lutt,
                  float_sw4* __restrict__ a_force,
                  float_sw4* __restrict__ a_rho, float_sw4 cof, sw4_type kic) {
  SW4_MARK_FUNCTION;
// Reversed indexation
#define Lutt(c, i, j, k) \
  a_lutt[-base3_lutt + i + ni * (j) + nij * (k) + nijk_lutt * (c)]
#define Unext(c, i, j, k) \
  a_unext[-base3_unext + i + ni * (j) + nij * (k) + nijk_unext * (c)]
#define force(c, i, j, k) \
  a_force[-base3_force + i + ni * (j) + nij * (k) + nijk_force * (c)]

// up and rho have different dimensions in the k-direction
#define up(c, i, j, k) a_up[-base3_u + i + ni * (j) + nij * (k) + nijk_u * (c)]
#define rho(i, j, k) a_rho[-base_rho + i + ni * (j) + nij * (k)]

  const sw4_type ni = ie - ib + 1;
  const sw4_type nij = ni * (je - jb + 1);
  const sw4_type base_rho = (ib + ni * jb + nij * kb);

  const sw4_type nijk_u = nij * (ke - kb + 1);
  const sw4_type base3_u = (ib + ni * jb + nij * kb + nijk_u);

  const sw4_type nijk_unext = nij * (1);
  const sw4_type base3_unext = (ib + ni * jb + nij * kic + nijk_unext);

  const sw4_type nijk_lutt = nij * (1);
  const sw4_type base3_lutt = (ib + ni * jb + nij * kic + nijk_lutt);

  const sw4_type nijk_force = nij * (1);
  const sw4_type base3_force = (ib + ni * jb + nij * kic + nijk_force);

  sw4_type c, j, i;
#pragma omp parallel private(i, j, c)
  {
    for (c = 1; c <= 3; c++) {
#pragma omp for
      for (j = jb + 2; j <= je - 2; j++) {
#pragma ivdep
        for (i = ib + 2; i <= ie - 2; i++) {
          Unext(c, i, j, kic) =
              up(c, i, j, kic) +
              cof * (Lutt(c, i, j, kic) + force(c, i, j, kic)) / rho(i, j, kic);
        }  // end for i
      }    // end for j
    }      // end for c

  }  // end omp parallel

#undef Unext
#undef up
#undef force
#undef Lutt
}  // end dpdmt_wind

//-----------------------------------------------------------------------
void dpdmt_wind(sw4_type ib, sw4_type ie, sw4_type jb, sw4_type je, sw4_type kb_tt, sw4_type ke_tt, sw4_type kb_u,
                sw4_type ke_u, float_sw4* __restrict__ a_up,
                float_sw4* __restrict__ a_u, float_sw4* __restrict__ a_um,
                float_sw4* __restrict__ a_utt, float_sw4 dt2i) {
  SW4_MARK_FUNCTION;
  // Reversed indexation
#define up(c, i, j, k) a_up[-base3_u + i + ni * (j) + nij * (k) + nijk_u * (c)]
#define u(c, i, j, k) a_u[-base3_u + i + ni * (j) + nij * (k) + nijk_u * (c)]
#define um(c, i, j, k) a_um[-base3_u + i + ni * (j) + nij * (k) + nijk_u * (c)]
// u_tt has different dimensions in the k-direction
#define u_tt(c, i, j, k) \
  a_utt[-base3_tt + i + ni * (j) + nij * (k) + nijk_tt * (c)]
  const sw4_type ni = ie - ib + 1;
  const sw4_type nij = ni * (je - jb + 1);

  const sw4_type nijk_u = nij * (ke_u - kb_u + 1);
  const sw4_type nijk_tt = nij * (ke_tt - kb_tt + 1);

  const sw4_type base3_u = (ib + ni * jb + nij * kb_u + nijk_u);
  const sw4_type base3_tt = (ib + ni * jb + nij * kb_tt + nijk_tt);

  //   sw4_type c, k, j, i;
  // #pragma omp parallel private(k,i,j,c)
  // {
  //   for (c=1; c<=3; c++)
  //   {
  //     for(k= kb_tt; k <= ke_tt ; k++ )
  //     {
  // #pragma omp for
  //       for(j=jb; j <= je ; j++ )
  //       {
  // #pragma simd
  // #pragma ivdep
  // 	for(i=ib; i <= ie ; i++ )
  // 	{
  // 	  u_tt(c,i,j,k) = dt2i*( up(c,i,j,k)-2*u(c,i,j,k)+um(c,i,j,k) );
  // 	}
  //       }
  //     }
  //   }

#if !defined(RAJA_ONLY) && defined(ENABLE_GPU)
  Range<16> I(ib, ie + 1);
  Range<4> J(jb, je + 1);
  Range<4> K(kb_tt, ke_tt + 1);
  forall3async(I, J, K, [=] RAJA_DEVICE(sw4_type i, sw4_type j, sw4_type k) {
#pragma unroll
    for (sw4_type c = 1; c < 4; c++)
      u_tt(c, i, j, k) =
          dt2i * (up(c, i, j, k) - 2 * u(c, i, j, k) + um(c, i, j, k));
  });

#else
  RAJA::RangeSegment i_range(ib, ie + 1);
  RAJA::RangeSegment j_range(jb, je + 1);
  RAJA::RangeSegment k_range(kb_tt, ke_tt + 1);
  // RAJA::RangeSegment c_range(1, 4);
  RAJA::kernel<DPDMT_WIND_LOOP_POL_ASYNC>(
      RAJA::make_tuple(i_range, j_range, k_range),
      [=] RAJA_DEVICE(sw4_type i, sw4_type j, sw4_type k) {
        for (sw4_type c = 1; c < 4; c++)
          u_tt(c, i, j, k) =
              dt2i * (up(c, i, j, k) - 2 * u(c, i, j, k) + um(c, i, j, k));
      });
#endif
  // SYNC_STREAM;
#undef up
#undef u
#undef um
#undef u_tt
}  // end dpdmt_wind
